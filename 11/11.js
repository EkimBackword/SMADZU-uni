const int N;     //Количество случайных точек
const int s;//Размер массива КА (без учета двух замыкающих ячеек)
const int m;     //Количество ячеек гистограммы
int h[m];    //Массив гистограммы
int A[s + 2];//Массив КА
const int d;//Размерность пространства
double x[d];//d-мерный массив случайных точек
...

srand((unsigned)time_t(0));          //Инициализация генератора псевдослучайных чисел

for (int j = 1; j <= s; j++)             //Цикл начальной инициализации массива КА
{
	double r = rand()/(double)RAND_MAX;
	if (r > 0.5) A[j] = 1;
	else A[j] = 0;
}
A[0] = A[s];                          //Замыкание границ массива
A[s + 1] = A[1];

for (int i = 0; i < N; i++)              //Цикл генерации N d-мерных случайных точек
{
	double x_max = 0;

	for (int j = 0; j < d; j++)
	{
		x[j] = KA_random();
		if (x_max < x[j]) x_max = x[j];
	}

	int k = int(m*exp(d*log(x_max)));      //Адрес ячейки, в которую попало d-							//мерное число x 
	h[k] = h[k] + 1;
}

double Pk = 1.0/m;        //Вероятность попадания в k-ю ячейку гистограммы

double Hi = 0;                                      //Расчет критерия хи-квадрат
for (int k = 0; k < m; k++)
{
	double temp = h[k] - N*Pk;
	Hi = Hi + temp*temp/(N*Pk);
}
 …
Функция KA_random(), необходимая для генерации каждого следующего случайного числа, имеет вид:
double KA_random()
{
  int B[s];                              //Вспомогательный массив для временного хранения массива A

  for (int j = 1; j <= s; j++)    //Перерасчет массива A по законам КА
  {
    int S = A[j - 1] + A[j] + A[j + 1];
    if (S%2 == 0)
      B[j] = 0;
    else
      B[j] = 1;
  }
  for (int j = 1; j <= s; j++)                    //Копирование новых значений из временного массива
    A[j] = B[j];
  A[0]     = A[s];                                    //Замыкание границ массива
  A[s + 1] = A[1];

  double x = 0;
  for (int j = 1; j <= s; j++)
    x = x + A[j]*exp((j - 1 - s)*log(2));    //Расчет случайного числа по элементам массива

  return x;
}
