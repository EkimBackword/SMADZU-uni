const int N;      //Количество случайных точек
const int m;  //Количество ячеек гистограммы
double a;//Параметр распределения Коши
double a_est;//Оценка параметра распределения Коши

int h[m + 2];//Массив гистограммы
double Pk[m + 2];//Массив вероятностей попадания в k-ю ячейку гистограммы
double x[N];      //Массив полученных случайных чисел
double x_sort[N];//Отсортированный массив случайных чисел
…
srand((unsigned)time_t(0));                   //Инициализация генератора псевдослучайных чисел

for (int k = 0; k <= m + 1; k++) 
{
	h[k] = 0;      //Обнуление гистограммы
}

for (int i = 1; i < N; i++)                      //Основной цикл генерации N случайных чисел
{
	double r = rand()/(double)RAND_MAX;
	x[i] = gamma*tan(3.141593*(r - 0.5)) + a;
}

for (int i = 0; i < N; i++)
{
	x_sort[i] = x[i];               //Копирование неотсортированного массива в 							//отсортированный
}

for (int k = 0; k < N; k++)
{
	for (int i = N; i >= k; i--)
	{
		if (x_sort[i] < x_sort[i - 1])
		{
			double t = x_sort [i];            //Временная переменная
			x_sort [i] = x_sort [i - 1];
			x_sort [i - 1] = t;
		}
	}
}

a_est = x_sort[N/2];

double dx = 10.0/m;                                    //Ширина ячейки гистограммы

for (int i = 0; i < N; i++) 
{                             //Цикл заполнения гистограммы
	if (x[i] < a_est - 5)             //Если полученное число меньше левой границы
	{
		h[0] = h[0] + 1;               //области гистограммирования, оно попадает в 						//нулевую ячейку…
	}
	else 
	{
		if (x[i] > a_est + 5)    //…а если оно больше правой границы,
		{
			h[m + 1] = h[m + 1] + 1; //оно попадает в (m+1)-ю ячейку
		}
		else
		{
			int k = int((x[i] - a_est + 5)/dx) + 1;     //Адрес ячейки, в которую 										//попало число x
			h[k] = h[k] + 1;
		}
	}
}

double tk[m + 1];                               //Массив координат границ ячеек гистограммы

for (int k = 1; k <= m; k++)
{
	tk[k] = a_est - 5 + (k - 1)*dx;
}

for (int k = 1; k <= m; k++)    //Расчет вероятностей попадания в k-ю ячейку 							//гистограммы
{
	Pk[k] = (atan((tk[k + 1] - a_est)/gamma) - atan((tk[k] - a_est)/gamma))/3.141593;
}	
Pk[0] = Pk[m + 1] = (atan((tk[1] - a_est)/gamma))/3.141593 + 0.5;

double Hi = 0;                                          //Расчет критерия хи-квадрат
for (int k = 1; k <= m; k++)
{
	double temp = h[k] - N*Pk[k];
	Hi = Hi + temp*temp/(N*Pk[k]);
}
